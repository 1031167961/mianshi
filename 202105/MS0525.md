## **2021年5月25日前端面试**

------
[TOC]
-----
## 1.HTML面试题

### **# 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？**

- 行内元素有：a b span img input select strong（强调的语气）
- 块级元素有：div ul ol li dl dt dd h1~h6…p
- 常见的空元素：br hr img input link meta

## 2.CSS面试题

### **# CSS选择器有哪些？哪些属性可以继承？**CSS优先级算法如何计算？CSS3新增伪类有那些?

#### 		CSS选择器：

- ##### **基础选择器**

  1. 元素选择器（选择元素名） 【如：p{color:red;}】

  2. ID选择器（#号+ID名）【如：#csdn{color:black;}】

  3. 类选择器（.+class名）【如：.csdn{color:blue;}】 

  4. 通配符选择器（选择全部元素，不建议使用）【如：* {color：green}】

  5. 并集选择器/组合选择器【如：p,h1,span{color:red;}】

     多个不同的标签，应用相同的样式/声明冲突时，需要分开计算

- ##### **层次选择器**

  1. 子级选择器 (元素之间用>分割)【如：p>span{color:red;}】
  2. 后代选择器（元素之间用空格分隔)【如：section span{color:blue;}】
  3. 兄弟选择武器（元素之间用+分隔)【如：h1+h2{color:green;}】

- ##### **伪类选择器**

  1. 动态伪类选择器：（网络通用：·爱恨原则·）

     **动态伪选择器的书写顺序**

     - link和visited必须放在最前面（无先后顺序,静态伪类选择器）
     - link和visited只能用于a标签
     - ink和visited后面是focus 
     - focus后面是hover
     - hover后面是active

  2. 结构为类选择器

     - 元素名：first-child第一个元素
     - 元素名：last-child最后一个元素
     - 元素名：nth-child(n)某一个元素 想选择第几个，n就取值多少
     - 元素名：nth-child(-n+m)选中前m个元素 n起始值是0
     - 元素名：nth-of-type(n) 选中第n个元素
     - 元素名：nth-last-child(n)选中倒数第n个元素

  3. 否定伪类选择器

     - 元素名：not（n）除了某个元素，其它元素添加样式

- ##### **伪元素选择器（CSS创建的元素,都是选中元素的子元素）**

  - 元素名：before(元素的第1个子元素)
  - 元素名：after(元素的最后1个子元素)
  - 元素名：first-letter(元素的第1个字)
  - 元素名：first-line(元素的第1个行)
  - input::-webkit-input-placeholder（修改输入框提示信息样式）

- ##### **属性选择器**

  - 元素名称[属性名+“属性值”]\如：input[type=“text”]

    - 格式： 元素名[属性名^=属性值开头的内容]选中以XXX开头的元素

      input[type^=“te”]+span{ color:red;}

    - 格式： 元素名[属性名 $ =属性值结尾的内容]选中以XXX结尾的元素

      input[type $ =“d”]+span{ color:blue;}

    - 格式： 元素名[属性名* =属性值包含的内容]选中包含XXX的元素

      input[type*=“i”]+span{ color:green;}

#### 	样式继承：

  - 可继承的属性：font-size, font-family, color
  - 不可继承的样式：border, padding, margin, width, height

#### CSS优先级：

优先级（就近原则）：!important > [ id > class > tag ]（important 比内联优先级高）

- 元素选择符： 1
- class选择符： 10
- id选择符：100
- 元素标签：1000

**注意**

1. !important声明的样式优先级最高，如果冲突再进行计算。
2. 如果优先级相同，则选择最后出现的样式。
3. 继承得到的样式的优先级最低。

#### 	CSS3新增伪类：

1. p:first-of-type 选择属于其父元素的首个元素
2. p:last-of-type 选择属于其父元素的最后元素
3. p:only-of-type 选择属于其父元素唯一的元素
4. p:only-child 选择属于其父元素的唯一子元素
5. p:nth-child(2) 选择属于其父元素的第二个子元素
6. :enabled :disabled 表单控件的禁用状态
7. :checked 单选框或复选框被选中

## 3.JS面试题

### **#  [对于js的原型和原型链的理解](https://blog.csdn.net/weixin_42614080/article/details/93413476)**

#### 原型与原型链

1.  **JavaScript是一门基于原型的语言**

   在软件设计模式中，有一种模式叫做原型模式，JavaScript正是利用这种模式而被创建出来

2. **原型模式是用于创建重复的对象，同时又能保证性能，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。**

   这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。原型模式的目的是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，也就是说利用已有的一个原型对象，可以快速地生成和原型对象一样的新对象实例

3. **原型**

   一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板

   ​	**总结：**

   - 所有引用类型都有一个`__proto__`(隐式原型)属性，属性值是一个普通的对象

   - 所有函数都有一个prototype(原型)属性，属性值是一个普通的对象

   - 所有引用类型的`__proto__`属性指向它构造函数的prototype

   ​	**原型的分类：**

   - **隐式原型（`_proto_`）**：上面说的这个原型是JavaScript中的内置属性[[prototype]]，此属性继承自object对象，在脚本中没有标准的方式访问[[prototype]]，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto_，隐式原型的作用是用来构成原型链，实现基于原型的继承
- **显示原型（prototype）**：每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享
  
4. **原型链**

   - **原型链：**原型链是原型对象创建过程的历史记录，当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构
   - **原型设计的问题：**当查找一个对象的属性时，JavaScript 会根据原型链向上遍历对象的原型，直到找到给定名称的属性为止，直到到达原型链的顶部仍然没有找到指定的属性，就会返回 undefined
     也可以理解为原型链继承时查找属性的过程是先查找自身属性，当自身属性不存在时，会在原型链中逐级查找
   - **hasOwnProperty 函数：**可以用来检查对象自身是否含有某个属性，返回值是布尔值，当属性不存在时不会向上查找对象原型链，hasOwnProperty是 JavaScript 中唯一一个处理属性但是不查找原型链的函数
   - **getOwnPropertyNames 函数：**可以获取对象所有的自身属性，返回值是由对象自身属性名称组成的数组，同样不会向上查找对象原型链
   - **原型链的小结**
     - 一直往上层查找，直到到null还没有找到，则返回undefined
     - `Object.prototype.__proto__ === null`
     - 所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象
   - **JavaScript的原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法**

#### 常见面试题

##### **Q1：谈谈你对原型的理解**？

​        在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象，使用原型对象的好处是所有对象实例共享它所包含的属性和方法

##### **Q2：什么是原型链？原型链解决的是什么问题**？

- 原型链解决的主要是继承问题

- 每个对象拥有一个原型对象，通过 proto 指针指向其原型对象，并从中继承方法和属性

  同时原型对象也可能拥有原型，这样一层一层，最终指向 null（Object.proptotype.`__proto__`指向的是null）

  这种关系被称为原型链(prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法

- 构造函数 Parent、Parent.prototype 和 实例 p 的关系如下：p.`__proto__` === Parent.prototype

  <img src="..\images\prototype.png" style="zoom:50%;" />

##### **Q3：prototype 和`__prop__ `区别是什么**？

- prototype是构造函数的属性
- `__proto__`是每个实例都有的属性，可以访问 [[prototype]] 属性
- 实例的`__proto__`与其构造函数的prototype指向的是同一个对象

## 4.VUE面试题

### # **v-show 与 v-if 有什么区别？**

#### **v-if：**

- 是真正的条件渲染
- 因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建
- 也是惰性的：如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块。

#### **v-show：**

- 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。

#### **应用场景：**

- v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景
- v-show 则适用于 需要非常频繁切换条件的场景。